var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));

// src/plugin/server/index.ts
import * as http from "http";
import { resolve } from "path";
import Koa from "koa";
import bodyParser from "koa-bodyparser";
import cors from "@koa/cors";
import getPort from "get-port";

// src/plugin/server/requests/get.ts
import * as fs from "fs/promises";
import Router from "koa-router";

// src/common/isNodeError.ts
function isNodeError(error) {
  return "code" in error;
}
var isNodeError_default = isNodeError;

// src/plugin/server/requests/get.ts
function createRoutes(resolvePath) {
  async function readFile2(path) {
    const data = await fs.readFile(path);
    return data;
  }
  async function readdir2(path, withFileTypes) {
    if (!withFileTypes) {
      const items2 = await fs.readdir(path);
      return items2;
    }
    const dirents = await fs.readdir(path, { withFileTypes: true });
    const items = [];
    dirents.forEach((dirent) => {
      const simpleDirent = {
        name: dirent.name,
        dir: dirent.isDirectory()
      };
      if (dirent.isFile() || dirent.isDirectory()) {
        items.push(simpleDirent);
      }
    });
    return items;
  }
  async function stat2(path) {
    const stats = await fs.stat(path);
    if (stats.isFile() || stats.isDirectory()) {
      const simpleStats = __spreadProps(__spreadValues({}, stats), {
        dir: stats.isDirectory()
      });
      return simpleStats;
    }
    throw new Error();
  }
  const router = new Router();
  router.get(/.*/, async (ctx) => {
    ctx.status = 500;
    ctx.body = "Relay server error";
    let path;
    try {
      path = resolvePath(ctx.path);
    } catch (err) {
      if (isNodeError_default(err)) {
        ctx.status = 403;
        ctx.body = err.message;
      }
      return;
    }
    if (ctx.query.cmd) {
      if (ctx.query.cmd === "readFile") {
        try {
          const response = await readFile2(path);
          ctx.status = 200;
          ctx.body = response;
          return;
        } catch (err) {
          if (isNodeError_default(err)) {
            if (err.code === "ENOENT") {
              ctx.status = 404;
              ctx.body = err.message;
              return;
            }
            ctx.status = 400;
            ctx.body = err.message;
          }
          return;
        }
      }
      if (ctx.query.cmd === "readdir") {
        if (ctx.query.withFileTypes) {
          try {
            const response = await readdir2(path, true);
            ctx.status = 200;
            ctx.body = response;
            return;
          } catch (err) {
            if (isNodeError_default(err)) {
              if (err.code === "ENOENT") {
                ctx.status = 404;
                return;
              }
              ctx.status = 400;
              ctx.body = err.message;
            }
            return;
          }
        } else {
          try {
            const response = await readdir2(path);
            ctx.status = 200;
            ctx.body = response;
            return;
          } catch (err) {
            if (isNodeError_default(err)) {
              if (err.code === "ENOENT") {
                ctx.status = 404;
                return;
              }
              ctx.status = 400;
              ctx.body = err.message;
            }
            return;
          }
        }
      }
      if (ctx.query.cmd === "stat") {
        try {
          const response = await stat2(path);
          ctx.status = 200;
          ctx.body = response;
          return;
        } catch (err) {
          if (isNodeError_default(err)) {
            if (err.code === "ENOENT") {
              ctx.status = 404;
              return;
            }
            ctx.status = 400;
            ctx.body = err.message;
          }
        }
      }
    } else {
      ctx.status = 400;
      ctx.body = "Command query param not specified";
    }
  });
  return router.routes();
}

// src/plugin/server/requests/post.ts
import * as fs2 from "fs/promises";
import { dirname } from "path";
import Router2 from "koa-router";
function createRoutes2(resolvePath) {
  const router = new Router2();
  router.post(/.*/, async (ctx) => {
    ctx.status = 500;
    ctx.body = "Relay server error";
    let path;
    try {
      path = resolvePath(ctx.path);
    } catch (err) {
      if (isNodeError_default(err)) {
        ctx.status = 403;
        ctx.body = err.message;
      }
      return;
    }
    if (ctx.query.cmd) {
      if (ctx.query.cmd === "writeFile") {
        const dir = dirname(path);
        const bdy = ctx.request.body;
        const { data } = bdy;
        try {
          try {
            await fs2.mkdir(dir, { recursive: true });
          } catch (err) {
          }
          await fs2.writeFile(path, data);
          ctx.status = 200;
        } catch (err) {
          ctx.status = 500;
        }
      }
    } else {
      ctx.status = 400;
      ctx.body = "Command query param not specified";
    }
  });
  return router.routes();
}

// src/plugin/server/requests/delete.ts
import * as fs3 from "fs/promises";
import Router3 from "koa-router";
function createRoutes3(resolvePath) {
  const router = new Router3();
  router.delete(/.*/, async (ctx) => {
    ctx.status = 500;
    ctx.body = "Relay server error";
    let path;
    try {
      path = resolvePath(ctx.path);
    } catch (err) {
      if (isNodeError_default(err)) {
        ctx.status = 403;
        ctx.body = err.message;
      }
      return;
    }
    if (ctx.query.cmd) {
      if (ctx.query.cmd === "rm") {
        let recursive = false;
        let force = false;
        if (ctx.query.recursive)
          recursive = true;
        if (ctx.query.force)
          force = true;
        try {
          await fs3.rm(path, { recursive, force });
          ctx.status = 200;
        } catch (err) {
          if (isNodeError_default(err)) {
            if (err.code === "ENOENT") {
              ctx.status = 404;
            } else if (err.code === "ERR_FS_EISDIR") {
              ctx.status = 400;
            } else {
              ctx.status = 500;
            }
            ctx.body = err.message;
          }
        }
      }
    } else {
      ctx.status = 400;
      ctx.body = "Command query param not specified";
    }
  });
  return router.routes();
}

// src/plugin/server/index.ts
var FsServer = class {
  server;
  rootDir;
  activePort;
  options;
  constructor(options) {
    this.options = options;
    this.rootDir = resolve(this.options.rootDir);
    const app = new Koa();
    app.use(bodyParser());
    app.use(cors());
    app.use(createRoutes(this.resolvePath));
    app.use(createRoutes2(this.resolvePath));
    app.use(createRoutes3(this.resolvePath));
    this.server = http.createServer(app.callback());
  }
  async start(silent) {
    const port = await getPort({ port: this.options.port });
    this.server.listen(port, () => {
      if (!silent) {
        console.log("\x1B[41m");
        console.log(`fs relay server is running on port ${port}`);
        console.log("Please be careful since any requests to this server can modify your actual file system");
        console.log(`\x1B[43m\x1B[30mThe relay server sees ${this.rootDir} as root. Everything outside this directory is safe`);
        console.log("\x1B[0m");
      }
    });
    this.activePort = port;
  }
  stop() {
    this.server.close();
  }
  resolvePath = (path) => {
    let cleanPath = path;
    while (cleanPath.length > 0 && cleanPath.startsWith("/")) {
      cleanPath = cleanPath.substring(1);
    }
    const p = resolve(this.rootDir, cleanPath);
    if (!p.startsWith(this.rootDir)) {
      throw new Error("ABOVEROOT");
    } else {
      return p;
    }
  };
};
var server_default = FsServer;

// src/plugin/Options.ts
var defaultOptions = {
  port: 7070,
  rootDir: ""
};
function resolveOptions(userOptiuons) {
  return Object.assign(defaultOptions, userOptiuons);
}

// src/plugin/index.ts
function VitePluginFs(userOptiuons = {}) {
  const options = resolveOptions(userOptiuons);
  const virtualModuleId = "virtual:fs";
  const resolvedVirtualModuleId = `\0${virtualModuleId}`;
  let server = null;
  let isProd = true;
  return {
    name: "vite-plugin-fs",
    apply: "serve",
    config(_, env) {
      if (env.mode === "development") {
        isProd = false;
      }
      return {
        build: {
          rollupOptions: {
            external: "virtual:fs"
          }
        },
        optimizeDeps: {
          exclude: [virtualModuleId]
        }
      };
    },
    async buildStart() {
      if (!isProd) {
        server = new server_default(options);
        await server.start();
      }
    },
    resolveId(id) {
      if (id === virtualModuleId) {
        return resolvedVirtualModuleId;
      }
      return null;
    },
    load(id) {
      if (typeof (server == null ? void 0 : server.activePort) === "number") {
        if (id === resolvedVirtualModuleId) {
          return `export const activePort = ${server.activePort}`;
        }
      }
      return null;
    },
    closeBundle() {
      server == null ? void 0 : server.stop();
    }
  };
}
var plugin_default = VitePluginFs;
export {
  plugin_default as default
};
